#include <stddef.h>
#include <stdint.h>

#include "terminal.h"
#include "print.h"
#include "serial.h"
#include "register.h"
#include "a20.h"

#include "interrupts.h"
#include "gdt.h"

#include "malloc.h"

extern void load_gdt(uint64_t *);
extern void e820(void);

extern void PM16(void);
extern uint32_t to_real_mode(void);

uint64_t GDT[6];
uint64_t GDT_16[2];

uint64_t
create_descriptor(uint32_t base, uint32_t limit, uint16_t flag)
{
  uint64_t descriptor;

  // Create the high 32 bit segment
  descriptor  =  limit       & 0x000F0000;         // set limit bits 19:16
  descriptor |= (flag <<  8) & 0x00F0FF00;         // set type, p, dpl, s, g, d/b, l and avl fields
  descriptor |= (base >> 16) & 0x000000FF;         // set base bits 23:16
  descriptor |=  base        & 0xFF000000;         // set base bits 31:24

  // Shift by 32 to allow for low part of segment
  descriptor <<= 32;

  // Create the low 32 bit segment
  descriptor |= base  << 16;                       // set base bits 15:0
  descriptor |= limit  & 0x0000FFFF;               // set limit bits 15:0

  //printf("0x%.16llX\n", descriptor);
  return descriptor;
}

void set_gdt()
{
  GDT[0] = create_descriptor(0, 0, 0);
  GDT[1] = create_descriptor(0, 0x000FFFFF, (GDT_CODE_PL0));
  GDT[2] = create_descriptor(0, 0x000FFFFF, (GDT_DATA_PL0));
  //  GDT[3] = create_descriptor(0, 0x000FFFFF, (GDT_CODE_PL3));
  //  GDT[4] = create_descriptor(0, 0x000FFFFF, (GDT_DATA_PL3));
  GDT[3] = create_descriptor(0, 0x0000FFFF, (GDT_CODE_PL0_16));
  GDT[4] = create_descriptor(0, 0x000FFFFF, (GDT_DATA_PL0_16));

  load_gdt(GDT);
}

void set_gdt_16()
{
  GDT_16[0] = create_descriptor(0, 0, 0);
  GDT_16[1] = create_descriptor(0, 0x0000FFFFF, (GDT_CODE_PL0_16));
  GDT_16[2] = create_descriptor(0, 0x0000FFFFF, (GDT_DATA_PL0_16));
  //  GDT[3] = create_descriptor(0, 0x000FFFFF, (GDT_CODE_PL3_16));
  //  GDT[4] = create_descriptor(0, 0x000FFFFF, (GDT_DATA_PL3_16));
  printk("set1\n");
  load_gdt(GDT_16);
}

extern void print_e820_map(void *);

void to_realmode()
{
  uint32_t retval = to_real_mode();
  printk("to real4: rc = %x\n", retval);
  printk("Out of realmode\n");
  
  print_e820_map((void *)retval);
}

#if 1

/* Values made available by the linker script */
extern void *__realmode_lma_start;
extern void *__realmode_lma_end;
extern void *__realmode_vma_start;

static void setup_realmode()
{
  /* Each of these __realmode* values is generated by the linker script */
  uint32_t *src_addr = (uint32_t *)&__realmode_lma_start;
  uint32_t *dst_addr = (uint32_t *)&__realmode_vma_start;
  uint32_t *src_end  = (uint32_t *)&__realmode_lma_end;

  /* Copy a DWORD at a time from source to destination */
  while (src_addr < src_end)
    *dst_addr++ = *src_addr++;
}
#endif

void is_protected()
{
  uint32_t val;
  asm volatile ("mov %%cr0, %0;" : "=r" (val) : );

  printk("mode:%x\n", val);

  #if 0
  if (val[0])
    {
      printk("Is protected\n");
    }
  else
    {
      printk("In Realmode\n");
    }
  #endif
}

void kmain(void)
{

  char asd[3];
  char zxc[4];
  char sdf[123];
  
  term_clrscr();

  idt_init();
  gen_int();
  serial_init();
  kb_init();

  setup_realmode();
  
  is_protected();
  
  char *bootmsg = "Starting genericOS";
  printk("%s\n", bootmsg);

  test_a20();

  to_realmode();

  mem_init();

  char *test = (char *)malloc(4);
  char *q = malloc(2);
  char *r = malloc(32);
  char *o = malloc(64);

  printk("test: %x\n", test);
  printk("q: %x\n", q);
  printk("r: %x\n", r);
  printk("o: %x\n", o);
  
  free(test);
  free(q);
  free(o);
  free(r);

  char *p = malloc(3);
  printk("p: %x\n", p);
  char *a = malloc(120);
  char *b = malloc(17);

  printk("a: %x\n", a);
  printk("b: %x\n", b);

  free(a);
  printk("freed a\n");
  char *c = malloc(20);
  printk("c: %x\n", c);

  
  while(1);
}
    
